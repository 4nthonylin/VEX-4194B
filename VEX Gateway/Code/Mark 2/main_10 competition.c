#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    select,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  pMode,          sensorDigitalOut)
#pragma config(Sensor, dgtl2,  pRes1,          sensorDigitalOut)
#pragma config(Sensor, dgtl3,  pRes2,          sensorDigitalOut)
#pragma config(Sensor, dgtl4,  Lencoder,       sensorRotation)
#pragma config(Sensor, dgtl5,  Rencoder,       sensorRotation)
#pragma config(Sensor, dgtl6,  bpckIN,         sensorTouch)
#pragma config(Sensor, dgtl7,  bpckOUT,        sensorTouch)
#pragma config(Sensor, dgtl8,  indicator1,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  indicator2,     sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftGear2,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           leftGear1,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port4,           leftCnvyr,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           leftBpck,      tmotorVex393, openLoop)
#pragma config(Motor,  port6,           rightBpck,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port7,           rightCnvyr,    tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightDrive,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           rightGear1,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          rightGear2,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

//variables
bool state = true; //true = drive, false = arm
bool drive_enable = true;
bool motor_enable = true;
bool mode = true; //true = speed, false = torque
bool autoarm = false; //true = pre-set arm heights, false = manual arm
bool reservoir1 = false;
bool reservoir2 = false;
bool brake_on = false;
bool disable_check = false;
int pneu1 = 0;
int pneu2 = 0;
int lift_rates[] = {0, 127, -127};
int lift_angles[] = {2160, 2730, 3062, 3710}; //stationary, small goal, medium goal, tall goal,
int arm_cycle = 0;
int motors[] = {0, 0, 0, 0, 0, 0, 0, 0}; //leftside, rightside, left drive, right drive, arm, conveyor, backpack
int temp[] = {0, 0, 0, 0, 0, 0, 0, 0};
int shaft_encoder[] = {0, 0};
int differences[] = {0, 0};
int arm_degree = 0;
int select_degree = 0;

//functions
int selector();
//int map(int x, int in_min, int in_max, int out_min, int out_max);
void setBase(int left, int right, int lift);
void arm(int target);
void motor_conditionals(int x, int y, int mag, int delay);
void straight(int speed);
void straight_distance(int clicks, int speed);
void straight_distance(int clicks, int speed, int timeout);
void turn(int speed);
void turn_distance(int clicks, int speed);
void zero();
void arm_change();
void autonomous0(int color);
void autonomous1(int color);
void autonomous2();
void autonomous3();
task autonomous();
task buttons();
task drive();
task motor_update();
task resevoir();
task arm_manager();
task sensor_get();
task indicators();
task different();

void pre_auton()
{
  zero();
  SensorValue[pMode] = 1;
  StartTask(drive);
  StartTask(motor_update);
  StartTask(resevoir);
  StartTask(arm_manager);
  StartTask(sensor_get);
  StartTask(indicators);
  StartTask(different);
  bStopTasksBetweenModes = false;
}

task autonomous()
{
  switch(selector()){
  case 0:
    autonomous0(1);
    break;

  case 1:
    autonomous1(1);
    break;

  case 2:
    autonomous0(-1);
    break;

  case 3:
    autonomous1(-1);
    break;

  case 4:
    autonomous2();
    break;
  case 5:
    autonomous3();
    break;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
  // User control code here, inside the loop
  StartTask(buttons);
  StartTask(drive);
  StartTask(motor_update);
  StartTask(resevoir);
  StartTask(arm_manager);
  StartTask(sensor_get);
  StartTask(indicators);
  StartTask(different);

  while(true){
    displayLCDCenteredString(0, "YO");
  }
}


void setBase(int left, int right, int lift){
  if(state){
    if(left <= 127)
      temp[0] = left;
    if(right <= 127)
      temp[1] = right;
  }
  if(!state){
    if(left <= 127)
      temp[2] = left;
    if(right <= 127)
      temp[3] = right;
    if(lift <= 127){
      motor[leftGear1] = lift;
      motor[leftGear2] = lift;
      motor[rightGear1] = lift;
      motor[rightGear2] = lift;
    }
  }
}

void arm(int target){
  if(!state && target > 0){
    while(SensorValue(potent) < target && (target - SensorValue(potent)) > 25 && autoarm)
      motors[4] = lift_rates[2];
    while(SensorValue(potent) > target && (SensorValue(potent) - target) > 25 && autoarm)
      motors[4] = lift_rates[1];
    motors[4] = lift_rates[0];
    //  autoarm = false;
    if(disable_check){
      autoarm = false;
      disable_check = false;
    }
  }
}

task arm_manager(){
  while(true){
    if(!autoarm) continue;
    //arm_change();
    if(arm_cycle < 0 || arm_cycle > 3) //ensures that the preset can never go below zero
      arm_cycle = 0;
    if(autoarm && !state)
      arm(lift_angles[arm_cycle]);
  }
}

void arm_change(){
  int place = 0;
  int difference[] = {0, 0, 0, 0};
  for(int x = 0; x <= 3; x++)
    difference[x] = abs(SensorValue(potent) - lift_angles[x]);
  for(int y = 0; y <=3; y++){
    for(int z = 0; z <= 3; z++){
      if(difference[place] <= difference[z]) continue;
      else if(difference[z] < difference[y]) place = z;
      else place = y;
    }
  }
  arm_cycle = place;
}

void zero(){
  SensorValue[Lencoder] = 0;
  SensorValue[Rencoder] = 0;
}

void straight(int speed){
  if(SensorValue[Lencoder] > SensorValue[Rencoder])
    setBase((speed - 10), speed, 200);
  if(SensorValue[Lencoder] < SensorValue[Rencoder])
    setBase(speed, (speed - 10), 200);
  if(SensorValue[Lencoder] == SensorValue[Rencoder])
    setBase(speed, speed, 200);
}

void straight_distance(int clicks, int speed){
  zero();
  while((SensorValue[Lencoder] + SensorValue[Rencoder])/2 < clicks)
    straight(speed);
}

void straight_distance(int clicks, int speed, int timeout){
  zero();
  ClearTimer(T4);
  while((SensorValue[Lencoder] + SensorValue[Rencoder])/2 < clicks && time100[T4] < timeout)
    straight(speed);
}

void turn(int speed){
  if(SensorValue[Lencoder] > SensorValue[Rencoder])
    setBase((speed - 10) * -1, speed, 200);
  if(SensorValue[Lencoder] < SensorValue[Rencoder])
    setBase(speed * -1, (speed - 10), 200);
  if(SensorValue[Lencoder] == SensorValue[Rencoder])
    setBase(speed * -1, speed, 200);
}

void turn_distance(int clicks, int speed){
  zero();
  while((SensorValue[Lencoder] + SensorValue[Rencoder])/2 < clicks)
    turn(speed);
}

task sensor_get(){
  while(true)
  {
    shaft_encoder[0] = SensorValue[Lencoder];
    shaft_encoder[1] = SensorValue[Rencoder];
    arm_degree = SensorValue(potent);
    select_degree = SensorValue(select);
  }
}

task different(){
  while(true)
  {
    differences[0] = shaft_encoder[0];
    differences[1] = shaft_encoder[1];
    wait1Msec(250);
  }
}

task resevoir(){
  while(true){
    if(reservoir1) pneu1 = 1;
    else pneu1 = 0;
    if(!reservoir2) pneu2 = 1;
    else pneu2 = 0;

    SensorValue[pRes1] = pneu1;
    SensorValue[pRes2] = pneu2;
  }
}

/*
int map(int x, int in_min, int in_max, int out_min, int out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
*/

void motor_conditionals(int x, int y, int mag, int delay){
  for(int index = x; index <= y; index++)
  {
    if(temp[index] > motors[index] && abs(temp[index] - motors[index]) > mag)
      motors[index] += mag;
    else if(temp[index] < motors[index] && abs(temp[index] - motors[index]) > mag)
      motors[index] -= mag;
    else if(temp[index] > (-1 * mag) && temp[index] < mag)
      motors[index] = 0;
    if(!brake_on && abs(temp[index] - motors[index]) > 127 && drive_enable && abs(temp[index]) > 100 && temp[index] < motors[index] && motors[index] >=0){
      brake_on = true;
      ClearTimer(T1);
      drive_enable = false;
    }
    else if(!brake_on && abs(temp[index] - motors[index]) > 127 && drive_enable && abs(temp[index]) > 100 && temp[index] > motors[index] && motors[index] < 0){
      brake_on = true;
      ClearTimer(T1);
      drive_enable = false;
    }
    if(brake_on && !drive_enable && time100[T1] >= 2){
      brake_on = false;
      drive_enable = true;
    }
    else if(brake_on){
      while(time100[T1] < 2){
        if(motors[index] > 0){
          motors[index]-= 7;
          if(motors[index] <= -127) motors[index] = -127;
        }
        else{
          motors[index]+= 7;
          if(motors[index] >=127) motors[index] = 127;
        }
      }
    }
  }
  wait1Msec(delay);
}

task indicators(){
  while(true){

    /*
    if((abs(vexRT[Ch3]) > 50 && shaft_encoder[0] - differences[0] == 0) || (abs(vexRT[Ch2]) > 50 && shaft_encoder[1] - differences[1] == 0)){
    SensorValue[indicator1] = 1;
    SensorValue[indicator2] = 1;
    wait1Msec(100);
    SensorValue[indicator1] = 0;
    SensorValue[indicator2] = 0;
    wait1Msec(100);
    }
    else{
    */
    if(state){
      SensorValue[indicator1] = 1;
      SensorValue[indicator2] = 0;
    }
    if(!state){
      if(!autoarm){
        SensorValue[indicator1] = 0;
        SensorValue[indicator2] = 1;
      }
      else{
        SensorValue[indicator1] = 0;
        SensorValue[indicator2] = 1;
        wait1Msec(250);
        SensorValue[indicator2] = 0;
        wait1Msec(250);
      }
      //   }
    }
  }
}

task buttons(){
  while(true){
    int i = 10;

    if(drive_enable){

      if(vexRT[Ch3Xmtr2] > 50 || vexRT[Ch3Xmtr2] < -50) i = 2;
      if(vexRT[Ch2Xmtr2] > 50 || vexRT[Ch2Xmtr2] < -50) i = 3;
      if(vexRT[Ch2Xmtr2] > 50 || vexRT[Ch2Xmtr2] < -50 && vexRT[Ch3Xmtr2] > 50 || vexRT[Ch3Xmtr2] < -50) i = 4;
      if(vexRT[Btn6U] == 1 || vexRT[Btn6UXmtr2] == 1) i = 0;
      else if(vexRT[Btn6D] == 1 || vexRT[Btn6DXmtr2] == 1) i = 1;
      switch(i) {
      case 0:
        motors[5] = 127;
        motors[6] = 127;
        break;
      case 1:
        motors[5] = -127;
        motors[6] = -127;
        break;
      case 2:
        motors[5] = vexRT[Ch3Xmtr2];
        motors[6] = 0;
        break;
      case 3:
        motors[5] = 0;
        motors[6] = vexRT[Ch2Xmtr2];
        break;
      case 4:
        motors[5] = vexRT[Ch3Xmtr2];
        motors[6] = vexRT[Ch2Xmtr2];
        break;
      default:
        motors[5] = 0;
        motors[6] = 0;
        break;
      }
    }

    if(vexRT[Btn8L] == 1 || vexRT[Btn8LXmtr2] == 1){
      reservoir2 = false;
      autoarm = false;
      mode = true;
      SensorValue(pMode) = 1;
      state = true;
    }
    if(vexRT[Btn8U] == 1 || vexRT[Btn8UXmtr2] == 1){
      reservoir2 = false;
      mode = false;
      autoarm = false;
      SensorValue(pMode) = 1;
      state = true;
    }
    if(vexRT[Btn8R] == 1 || vexRT[Btn8RXmtr2] == 1){
      reservoir2 = false;
      SensorValue(pMode) = 0;
      state = false;
    }

    if(vexRT[Btn8D] == 1 || vexRT[Btn8DXmtr2] == 1){
      reservoir2 = true;
    }


    if(vexRT[Btn7D] == 1 || vexRT[Btn7DXmtr2] == 1){
      arm_change();
      arm_cycle--;
      autoarm = true;
      wait1Msec(200);
    }

    if(vexRT[Btn7U] == 1 || vexRT[Btn7UXmtr2] == 1){
      arm_change();
      arm_cycle++;
      autoarm = true;
      wait1Msec(200);
    }

    if(vexRT[Btn7RXmtr2] == 1){
      arm_change();
      arm_cycle = 0;
      autoarm = true;
      wait1Msec(200);
    }

    //   if(vexRT[Btn7R] == 1) StartTask(autonomous);
    /*
    if(vexRT[Btn7L] == 1) {
    motor_enable = !motor_enable;
    wait1Msec(1000);
    }
    */

    if(!state){
      if(vexRT[Btn5U] == 1 || vexRT[Btn5UXmtr2] == 1){
        autoarm = false;
        motors[4] = lift_rates[2];
      }
      else if(vexRT[Btn5D] == 1 || vexRT[Btn5DXmtr2] == 1){
        autoarm = false;
        motors[4] = lift_rates[1];
      }
      else if(vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0 && vexRT[Btn5UXmtr2] == 0 && vexRT[Btn5DXmtr2] == 0 && !autoarm)
        motors[4] = lift_rates[0];
    }
  }
}

task drive(){
  while(true){
    if(drive_enable){
      if(state){
        temp[0] = vexRT[Ch3];
        temp[1] = vexRT[Ch2];
      }
      else{
        temp[2] = vexRT[Ch3];
        temp[3] = vexRT[Ch2];
      }
    }
  }
}

task motor_update(){
  while(true){
    if(motor_enable){
      if(state){
        motor_conditionals(0, 1, 2, 1);
        if(mode){
          motor[leftDrive] = motors[0] * -1;
          motor[leftGear1] = motors[0];
          motor[leftGear2] = motors[0];
          motor[rightDrive] = motors[1] * -1;
          motor[rightGear1] = motors[1];
          motor[rightGear2] = motors[1];
        }
        else{
          motor[leftDrive] = motors[0] / -10;
          motor[leftGear1] = motors[0] * -1;
          motor[leftGear2] = motors[0] * -1;
          motor[rightDrive] = motors[1] / -10;
          motor[rightGear1] = motors[1] * -1;
          motor[rightGear2] = motors[1] * -1;
        }
      }
      else{
        motor_conditionals(2, 3, 2, 1);
        motor[leftDrive] = motors[2] * -1;
        motor[rightDrive] = motors[3] * -1;
        setBase(200, 200, motors[4]);
      }
      motor[leftCnvyr] = motors[5];
      motor[rightCnvyr] = motors[5];
      if(SensorValue[bpckOUT] == 0 && motors[6] > 0){
        motor[leftBpck] = motors[6];
        motor[rightBpck] = motors[6];
      }
      else if(SensorValue[bpckIN] == 0 && motors[6] < 0){
        motor[leftBpck] = motors[6];
        motor[rightBpck] = motors[6];
      }
      else{
        motor[leftBpck] = 0;
        motor[rightBpck] = 0;
      }
    }
    else{
      motor[leftDrive] = 0;
      motor[leftGear1] = 0;
      motor[leftGear2] = 0;
      motor[rightDrive] = 0;
      motor[rightGear1] = 0;
      motor[rightGear2] = 0;
      motor[leftCnvyr] = 0;
      motor[rightCnvyr] = 0;
      motor[leftBpck] = 0;
      motor[rightBpck] = 0;
    }
  }
}

int selector(){
  int buffer = 0;
  if(select_degree <= 720) buffer = 0;
  if(select_degree <= 1440 && select_degree > 720) buffer = 1;
  if(select_degree <= 2160 && select_degree > 1440) buffer = 2;
  if(select_degree <= 2880 && select_degree > 2160) buffer = 3;
  if(select_degree <= 3600 && select_degree > 2880) buffer = 4;
  if(select_degree <= 4100 && select_degree > 3600) buffer = 5;

  return buffer;
}

void autonomous0(int color){
  drive_enable = false;
  SensorValue(pMode) = 0;
  state = false;
  arm_cycle = 2;
  autoarm = true;
  straight_distance(110, 80, 40);
  setBase(0, 0, 200);
  while(arm_degree < lift_angles[arm_cycle]);
  motors[5] = -127;
  wait1Msec(2000);
  motors[5] = 0;
  arm_cycle = 0;
  straight_distance(120, -80, 30);
  setBase(0, 0, 200);
  wait1Msec(3000);
  SensorValue(pMode) = 1;
  wait1Msec(50);
  motors[5] = 127;
  motors[6] = 127;
  straight_distance(325, 50);
  motors[5] = 0;
  straight_distance(115, -50);
  setBase(0, 0, 200);
  SensorValue(pMode) = 0;
  wait10Msec(10);
  arm_cycle = 2;
  state = false;
  autoarm = true;
  while(arm_degree < lift_angles[arm_cycle]);
  SensorValue(pMode) = 0;
  state = true;
  setBase(0, 0, 200);
  /*
  motors[5] = -127;
  motors[6] = -127;
  wait1Msec(3000);
  motors[5] = 0;
  motors[6] = 0;
  */
  drive_enable = true;
}

void autonomous1(int color){
  drive_enable = false;
  SensorValue(pMode) = 1;
  motor[leftCnvyr] = 127;
  motor[rightCnvyr] = 127;
  motors[6] = 127;
  straight_distance(325, 50);
  motors[5] = 0;
  straight_distance(100, -50);
  setBase(0, 0, 200);
  SensorValue(pMode) = 0;
  wait10Msec(2);
  arm_cycle = 2;
  state = false;
  autoarm = true;
  while(arm_degree < lift_angles[arm_cycle]);
  SensorValue(pMode) = 1;
  state = true;
  turn_distance(40, -120 * color);
  straight_distance(15, 60);
  setBase(0, 0, 200);
  motors[5] = 0;
  motors[6] = 0;
  drive_enable = true;
}

void autonomous2(){
  mode = true;
  setBase(0, 0, 200);
  drive_enable = false;
  SensorValue[pMode] = 0;
  arm_cycle = 1;
  state = false;
  autoarm = true;
  while(arm_degree <= lift_angles[arm_cycle]){
    if(SensorValue[bpckOUT] == 0)
      motors[6] = 127;
  }
  motors[6] = 0;
  state = true;
  SensorValue[pMode] = 1;
  straight_distance(100, -127, 30);
  setBase(0, 0, 200);
  wait1Msec(500);
  straight_distance (125, 127, 30);
  setBase(0, 0, 200);
  ClearTimer(T3);
  while(time100[T3] < 30){
    if(arm_degree < lift_angles[arm_cycle]){
      SensorValue[pMode] = 0;
      state = false;
      autoarm = true;
    }
  }
  motors[5] = -127;
  wait1Msec(2000);
  motors[5] = 0;
  wait1Msec(5000);
  arm_cycle = 3;
  autoarm = true;
  SensorValue[pMode] = 0;
  state = false;
  disable_check = true;
  straight_distance(252, 60, 40);
  setBase(0, 0, 200);
  drive_enable = true;
}

void autonomous3(){
  while(SensorValue(bpckOUT) == 0) motors[6] = 127;
  motors[6] = 0;
  straight_distance(250, -80);
  setBase(0, 0, 200);
}
