#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    dummy,          sensorNone)
#pragma config(Sensor, in3,    leftLift,       sensorPotentiometer)
#pragma config(Sensor, in4,    rightLift,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorRotation)
#pragma config(Sensor, dgtl2,  rightEncoder,   sensorRotation)
#pragma config(Sensor, dgtl3,  leftDump,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  rightDump,      sensorDigitalOut)
#pragma config(Motor,  port1,           LeftDrive1,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           LeftDrive2,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           LeftLift1,     tmotorVex393, openLoop)
#pragma config(Motor,  port4,           LeftLift2,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           LeftRoller,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           RightRoller,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           RightLift2,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           RightLift1,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           RightDrive2,   tmotorVex393, openLoop)
#pragma config(Motor,  port10,          RightDrive1,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

int lift_levels[] = {0, 1400};
int lift_rates[] = {127, -80, 15};
int lift_state = 0; //0 up, 1 down, 2 neutral
int roller_state = 0; //0 nom, 1 spit, 2 neutral
int leftPotent;
int rightPotent;
int arm_cycle = 0;

bool autoarm = true;
bool dump_state = false; //true = dump, false = not dump
bool disable_check = false;
bool drive_enable = true;
bool maximum_speed = false;

string mainBattery, backupBattery;

void autonomous1();
void setMotors(int left, int right);
void setLift(int lift);
void lift(int target);
void straight(int speed);
void straight_distance(int clicks, int speed);
void straight_distance(int clicks, int speed, int timeout);
void zero();

task arm();
task drive();
task button();
task sensor();
task arm_manager();
task dump();
task lcd();

void pre_auton()
{
	zero();
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	StartTask(sensor);

}

task autonomous()
{
		drive_enable = false;
		motor[LeftRoller] = -127;
	motor[RightRoller] = -127;
	wait1Msec(1000);
	motor[LeftRoller] = 127;
	motor[RightRoller] = 127;
	straight_distance(600, 60, 20);
	setMotors(0, 0);
	for(int x = 0; x < 5; x++){
		straight_distance(50, 60);
		setMotors(0, 0);
		wait1Msec(500);
		straight_distance(50, -60);
		setMotors(0, 0);
		wait1Msec(500);
	}
	straight_distance(50, 60);
	wait1Msec(1000);
	motor[LeftRoller] = 0;
	motor[RightRoller] = 0;
	straight_distance(500, -127, 30);
	setMotors(0, 0);
	drive_enable = true;


}

task usercontrol()
{

	while (true)
	{
		drive_enable = true;
		StartTask(arm);
		StartTask(drive);
		StartTask(button);
		StartTask(sensor);
		StartTask(arm_manager);
		StartTask(dump);
		StartTask(lcd);
	}
}

task arm(){
	switch(lift_state){
	case 0:
		autoarm = false;
		setLift(lift_rates[0]);
		break;
	case 1:
		autoarm = false;
		if(SensorValue[leftLift] > lift_levels[0]){
			if(!maximum_speed) setLift(lift_rates[1]);
			else setLift(-127);
		}
		break;
	case 2:
		if(!autoarm) setLift(lift_rates[2]);
		break;

	}

	switch(roller_state){
	case 0:
		motor[LeftRoller] = 127;
		motor[RightRoller] = 127;
		break;
	case 1:
		motor[LeftRoller] = -127;
		motor[RightRoller] = -127;
		break;
	case 2:
		motor[LeftRoller] = 0;
		motor[RightRoller] = 0;
		break;
	}
}

task drive(){
	if(drive_enable) setMotors(vexRT[Ch3], vexRT[Ch2]);
}

task button(){
	if(vexRT[Btn5U] == 1) lift_state = 0;
	else if(vexRT[Btn5D] == 1) lift_state = 1;
	else if(!autoarm) lift_state = 2;

	if(vexRT[Btn6U] == 1) roller_state = 0;
	else if(vexRT[Btn6D] == 1) roller_state = 1;
	else roller_state = 2;

	if(vexRT[Btn8L] == 1) dump_state = false;
	else if(vexRT[Btn8D]) dump_state = true;

	if(vexRT[Btn7D] == 1){
		arm_cycle = 0;
		autoarm = true;
		wait1Msec(100);
	}

	if(vexRT[Btn7U] == 1){
		arm_cycle = 1;
		autoarm = true;
		wait1Msec(100);
	}

	if(vexRT[Btn7L] == 1) maximum_speed = false;
	else if(vexRT[Btn7R] == 1) maximum_speed = true;

	//if(vexRT[Btn8R]) autonomous1();
}

task sensor(){
	while(true){
		leftPotent = SensorValue[leftLift];
		rightPotent = SensorValue[rightLift];
	}
}

task arm_manager(){
	while(true){
		if(!autoarm) continue;
		if(autoarm) lift(lift_levels[arm_cycle]);
	}
}

task lcd(){
	clearLCDLine(0);											// Clear line 1 (0) of the LCD
	clearLCDLine(1);											// Clear line 2 (1) of the LCD

	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);

	//Display the Backup battery voltage
	displayLCDString(1, 0, "Backup: ");
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
	displayNextLCDString(backupBattery);

	//Short delay for the LCD refresh rate
	wait1Msec(100);
}

void setMotors(int left, int right){
	motor[LeftDrive1] = left;
	motor[LeftDrive2] = left;
	motor[RightDrive1] = right;
	motor[RightDrive2] = right;
}


void setLift(int lift){
	motor[LeftLift1] = lift;
	motor[LeftLift2] = lift;
	motor[RightLift1] = lift;
	motor[RightLift2] = lift;
}

task dump(){
	switch(dump_state){
	case true:
		SensorValue[leftDump] = 1;
		SensorValue[rightDump] = 1;
		break;
	case false:
		SensorValue[leftDump] = 0;
		SensorValue[rightDump] = 0;
	}
}

void lift(int target){
	if(target > 0){
		while(leftPotent < target && (target - leftPotent) > 50 && autoarm){
			setLift(lift_rates[0]);
		}
		while(leftPotent > target && (leftPotent - target) > 50 && autoarm){
			setLift(lift_rates[1]);
		}
		setLift(lift_rates[2]);

		if(disable_check){
			autoarm = false;
			disable_check = false;
		}
	}
}

void zero(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void straight(int speed){
	if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
		setMotors((speed - 10), speed);
	if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
		setMotors(speed, (speed - 10));
	if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
		setMotors(speed, speed);
}

void straight_distance(int clicks, int speed){
	zero();
	while((SensorValue[leftEncoder] + SensorValue[rightEncoder])/2 < clicks)
		straight(speed);
}

void straight_distance(int clicks, int speed, int timeout){
	zero();
	ClearTimer(T4);
	while((SensorValue[leftEncoder] + SensorValue[rightEncoder])/2 < clicks && time100[T4] < timeout)
		straight(speed);
}

void autonomous1(){
	drive_enable = false;
		motor[LeftRoller] = -127;
	motor[RightRoller] = -127;
	wait1Msec(1000);
	motor[LeftRoller] = 127;
	motor[RightRoller] = 127;
	straight_distance(600, 60, 30);
	setMotors(0, 0);
	for(int x = 0; x < 5; x++){
		straight_distance(50, 60);
		setMotors(0, 0);
		wait1Msec(500);
		straight_distance(50, -60);
		setMotors(0, 0);
		wait1Msec(500);
	}
	straight_distance(50, 60);
	wait1Msec(1000);
	motor[LeftRoller] = 0;
	motor[RightRoller] = 0;
	straight_distance(500, -127, 30);
	setMotors(0, 0);
	drive_enable = true;

}
