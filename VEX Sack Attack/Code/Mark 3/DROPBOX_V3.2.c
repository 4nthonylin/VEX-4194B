#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in4,    pwr_expander,   sensorAnalog)
#pragma config(Sensor, dgtl1,  basePneumatics, sensorDigitalOut)
#pragma config(Sensor, dgtl2,  clawPneumatics, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  leftUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  bLeftUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  topUltrasonic,  sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  bRightUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, dgtl11, rightUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftRoll,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           leftDriveF,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftDriveB,    tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           leftLift1,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           leftLift2,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           rightLift2,    tmotorVex393, openLoop)
#pragma config(Motor,  port7,           rightLift1,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightDriveB,   tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port9,           rightDriveF,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          rightRoll,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//AUTONOMOUS TURN VALUES
int RIGHT_TURN = 950;

int globalVar;

int armSpeed[] = {10, 127, -60}; //0 = neutral, 1 = lift, 2 = down
int INTAKE_SPEED = 127;
bool strafe = false;
bool driveEnable = true;
bool autoarm = false; //true = pre-set arm heights, false = manual arm
bool disable_check = false;
int arm_cycle = 0;
int lift_angles[] = {58, 2170, 1558, 1000}; //zero, trough, high goal, expansion height
// constants to be used with arm_cycle
int NEUTRAL = 0;
int TROUGH = 1;
int HIGH_GOAL = 2;
int EXPANSION = 3;

void arm(int target);
void arm_change();
void setDrive(int left, int right);
void setDrive(int strafe);
void setDrive(int leftFront, int leftBack, int rightFront, int rightBack);
void runExpansion();
void setArm(int lift);
void setIntake(int speed);
void brake(int counter);
int map(int x, int in_min, int in_max, int out_min, int out_max);


task drive();
//task arm_lift();
task buttons();
task pneumatics();
task arm_manager();

// AUTONOMOUS VARIABLES ==========
int sideSelector; // currently selected side
int LEFT = 0;
int RIGHT = 1;
int UP = 1;
int DOWN = 2;
string sides[] = {" LEFT ", " RIGHT"};
int autoSelector; // currently selected routine
int numAutos = 4; // number of autonomous routines
// autonomous routine tasks
string autoNames[] = {"Expand & Sit",
	"Score Trough",
	"Block",
	"Move Forward"};

// autonomous routines
void expandSit(int side);
void scoreTrough(int side);
void block(int side);
void moveForward(int side);

void turn(int speed);
void turn_rotate(int speed, int clicks);
void straight(int speed);
void straight_distance(int speed, long clicks);
void clearEncoder();
// named subroutines
// ===============================


task drive(){
	if(driveEnable){
		//setDrive(vexRT[Ch3], vexRT[Ch2]);
		motor[leftDriveF] = vexRT[Ch3] + vexRT[Ch4];
		motor[leftDriveB] = vexRT[Ch3] - vexRT[Ch4];
		motor[rightDriveF] = vexRT[Ch2] - vexRT[Ch1];
		motor[rightDriveB] = vexRT[Ch2] + vexRT[Ch1];
	}
}

task buttons(){
	if(vexRT[Btn8U] == 1) strafe = true;
	if(vexRT[Btn8D] == 1) strafe = false;

	if(vexRT[Btn7D] == 1){
		arm_change();
		arm_cycle--;
		autoarm = true;
		wait1Msec(100);
	}

	if(vexRT[Btn7U] == 1){
		arm_change();
		arm_cycle++;
		autoarm = true;
		wait1Msec(100);
	}

	if(vexRT[Btn5U] == 1){
		autoarm = false;
		setArm(armSpeed[1]);
	}
	else if(vexRT[Btn5D] == 1){
		autoarm = false;
		setArm(armSpeed[2]);
	}
	else if(vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0 && !autoarm)
		setArm(armSpeed[0]);

	if(vexRT[Btn8R] == 1) SensorValue(clawPneumatics) = 1;
	if(vexRT[Btn8L] == 1) SensorValue(clawPneumatics) = 0;

	if(vexRT[Btn6U] == 1) setIntake(INTAKE_SPEED);
	else if(vexRT[Btn6D] == 1) setIntake(-INTAKE_SPEED);
	else setIntake(0);
}



task pneumatics(){
	if(strafe){
		SensorValue(basePneumatics) = 1;
	}
	else{
		SensorValue(basePneumatics) = 0;
	}
}

void setDrive(int left, int right){
	motor[leftDriveF] = left;
	motor[leftDriveB] = left;
	motor[rightDriveF] = right;
	motor[rightDriveB] = right;
}

void setDrive(int strafe){
	motor[leftDriveF] = strafe * -1;
	motor[leftDriveB] = strafe;
	motor[rightDriveF] = strafe;
	motor[rightDriveB] = strafe * -1;
}

// lifts arm to target value
void arm(int target){
	if(target > 0){
		while(SensorValue(potent) < target && (target - SensorValue(potent)) > 25 && autoarm)
			setArm(armSpeed[1]);
		while(SensorValue(potent) > target && (SensorValue(potent) - target) > 25 && autoarm)
			setArm(armSpeed[2]);
		setArm(armSpeed[0]);
		//autoarm = false;
		if(disable_check){
			autoarm = false;
			disable_check = false;
		}
	}
}

task arm_manager(){
	while(true){
		if(!autoarm) continue;
		//arm_change();
		if(arm_cycle < NEUTRAL || arm_cycle > 2) //ensures that the preset can never go below zero
			arm_cycle = NEUTRAL;
		if(autoarm)
			arm(lift_angles[arm_cycle]);
	}
}

void arm_change(){
	int place = 0;
	int difference[] = {0, 0, 0, 0};
	for(int x = 0; x <= 3; x++)
		difference[x] = abs(SensorValue(potent) - lift_angles[x]);
	for(int y = 0; y <=3; y++){
		for(int z = 0; z <= 3; z++){
			if(difference[place] <= difference[z]) continue;
			else if(difference[z] < difference[y]) place = z;
			else place = y;
		}
	}
	arm_cycle = place;
}


// NE - setDrive(1,0,0,1);
// NW - setDrive(0,1,1,0);
// SW - setDrive(-1,0,0,-1);
// SE - setDrive(0,-1,-1,0);
void setDrive(int leftFront, int leftBack, int rightFront, int rightBack) {
	motor[leftDriveF] = leftFront;
	motor[leftDriveB] = leftBack;
	motor[rightDriveF] = rightFront;
	motor[rightDriveB] = rightBack;
}

void runExpansion(){
	// engage drive pneumatics
	strafe = true;
	SensorValue(basePneumatics) = 1;
	autoarm = true;
	arm_cycle = HIGH_GOAL;
	// move forward and backward
	setDrive(127,127);
	wait1Msec(500);
	setDrive(-127,-127);
	wait1Msec(500);

	// strafe apart
	motor[leftDriveF] = -127;
	motor[leftDriveB] = 127;
	motor[rightDriveF] = -127;
	motor[rightDriveB] = 127;
	wait1Msec(1000);
	brake(0);
	arm_cycle = NEUTRAL;
	// lift arm to bring down intake module
	motor[leftDriveF] = -127;
	motor[leftDriveB] = 127;
	motor[rightDriveF] = -127;
	motor[rightDriveB] = 127;
	wait1Msec(1000);

}

void setArm(int lift){
	motor[leftLift1] = lift;
	motor[leftLift2] = lift;
	motor[rightLift1] = lift;
	motor[rightLift2] = lift;
}

void setIntake(int speed){
	motor[leftRoll] = speed;
	motor[rightRoll] = speed;
}

void brake(int counter){
	setDrive(counter, counter);
	if(counter != 0) wait1Msec(50);
	setDrive(0, 0);
}

// ======================
// AUTONOMOUS SUBROUTINES
// ======================
void driveNE(int cw, int ccw) {
	setDrive(cw, 0, 0, ccw);
}
void driveNW(int cw, int ccw) {
	setDrive(0, cw, ccw, 0);
}
void driveSW(int cw, int ccw) {
	setDrive(-ccw, 0, 0, -cw);
}
void driveSE(int cw, int ccw) {
	setDrive(0, -ccw, -cw, 0);
}

// lines up with the 5-sack stack
void diagonalSidle(int dist, int speed, int side) {
	int rotateCW = speed; // clockwise rotation
	int rotateCCW = speed; // counterclockwise rotation

	if(side == LEFT) {
		/*
		while(SensorValue(leftUltrasonic) > dist) {
		// drive NE
		setDrive(0, rotateCW, rotateCCW, 0);
		}
		*/
	}
	else if(side == RIGHT) {
		while(SensorValue(rightUltrasonic) < dist) {
			// drive NW
			if(SensorValue(bLeftUltrasonic) >= SensorValue(bRightUltrasonic)) { // too far clockwise
				rotateCCW = speed++;
				rotateCW = speed--;
				} else { // too far counterclockwise
				rotateCCW = speed--;
				rotateCW = speed++;
			}
			driveNW(rotateCW, rotateCCW);

		}
	}
	brake(0);
}

void alignLine(int value, int speed) {
	/*
	bool leftPassed = false;
	bool rightPassed = false;
	while(SensorValue(leftLineFollower) > value && SensorValue(rightLineFollower) > value){
		straight(speed);
		if(SensorValue(leftLineFollower) <= value) leftPassed= true;
		else if(SensorValue(rightLineFollower) <= value) rightPassed = true;
	}
	brake(-10);

	while(SensorValue(leftLineFollower) > value || SensorValue(rightLineFollower) > value){
		if(leftPassed || SensorValue(leftLineFollower) <= value){
			leftPassed = false;
			setDrive(0, speed/2);
		}
		if(rightPassed || SensorValue(rightLineFollower) <= value){
			rightPassed = false;
			setDrive(speed/2, 0);
		}
	}



	*/
	int leftMotor;
	int rightMotor;
	bool leftPassed = false;
	bool rightPassed = false;
	while(!rightPassed || !leftPassed) {
	if(SensorValue(leftLineFollower) < value) {
	leftPassed = true;
	}
	if(!leftPassed) {
	leftMotor = speed;
	}
	else {
	leftMotor = 0;
	}
	if(SensorValue(rightLineFollower) < value) {
	rightPassed = true;
	}
	if(!rightPassed) {
	rightMotor = speed;
	}
	else {
	rightMotor = 0;
	}
	setDrive(leftMotor,rightMotor);
	}
	brake(0);

}

void alignBack(int dist, int speed) {
	int leftMotor;
	int rightMotor;
	int threshold = 0;
	while(SensorValue(bLeftUltrasonic) > dist + threshold  || SensorValue(bLeftUltrasonic) < dist - threshold
		|| SensorValue(bRightUltrasonic) > dist + threshold || SensorValue(bRightUltrasonic) < dist - threshold) {
		if(SensorValue(bLeftUltrasonic) > dist + threshold) {
			leftMotor = -speed;
		}
		else if(SensorValue(bLeftUltrasonic) < dist - threshold) {
			leftMotor = speed;
		}
		else {
			leftMotor = 0;
		}
		if(SensorValue(bRightUltrasonic) > dist + threshold) {
			rightMotor = -speed;
		}
		else if (SensorValue(bLeftUltrasonic) < dist - threshold) {
			rightMotor = speed;
		}
		else {
			rightMotor = 0;
		}
		setDrive(leftMotor, rightMotor);
	}
	brake(10);
}

void troughMacro(int speed) {
	// starts with back facing the trough
	// 1. move back and lift up
	while(SensorValue(topUltrasonic) > 23){
		straight(-speed);
	}
	brake(10);
	arm_change();
	arm_cycle = TROUGH;
	autoarm = true;
	while(SensorValue(potent) < 1800);
	straight_distance(-60, 150);
	while(SensorValue(potent) < lift_angles[1]);
	// 2. move forward and drop lift
}

// ===================
// AUTONOMOUS ROUTINES
// ===================
//DEFAULT AUTONOMOUS TURNING SPEED = 80

void expandSit(int side) {
	// 0: Expand & Sit
	runExpansion();
}
void scoreTrough(int side) {
	// 1: Score Trough
	/*
	runExpansion();
	*/
	int speed1 = 100;
	int dist = 93; // distance from arena wall before break
	diagonalSidle(dist, speed1, side); // MOVE DIAGONAL
	setIntake(INTAKE_SPEED); // NOM
	alignLine(1600, 60); // straight until aligned with line
	setIntake(0); // STOP NOM
	int rotate = 2400; // rotation clicks for 180 turn
	turn_rotate(speed1, rotate); // TURN 180
	troughMacro(100);
	/*
	int clicks2 = 150; // backup distance: adjust this
	int speed2 = 70;
	arm_cycle = TROUGH; // LIFT TO TROUGH LEVEL
	straight_distance(speed2, clicks2); // BACK UP
	arm_cycle = NEUTRAL; // DROP LIFT
	straight_distance(speed2, clicks2); // MOVE FORWARD
	*/
}
void block(int side) {
	// 2: Block

}
void moveForward(int side) {
	// 3: Move Forward
}

int map(int x, int in_min, int in_max, int out_min, int out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void clearEncoder(){
	nMotorEncoder[leftDriveB] = 0;
	nMotorEncoder[rightDriveB] = 0;
}

void turn(int speed){
	if(speed > 0){
		if(abs(nMotorEncoder[leftDriveB]) > abs(nMotorEncoder[rightDriveB]))
			setDrive(-speed + 10, speed);
		if(abs(nMotorEncoder[leftDriveB]) < abs(nMotorEncoder[rightDriveB]))
			setDrive(-speed, speed - 10);
	}
	else{
		if(abs(nMotorEncoder[leftDriveB]) > abs(nMotorEncoder[rightDriveB]))
			setDrive(-speed + 10, speed);
		if(abs(nMotorEncoder[leftDriveB]) < abs(nMotorEncoder[rightDriveB]))
			setDrive(-speed, speed - 10);
	}
	if(abs(nMotorEncoder[leftDriveB]) == abs(nMotorEncoder[rightDriveB]))
		setDrive(-speed, speed);
}

void turn_rotate(int speed, int clicks){
	clearEncoder();
	while((abs(nMotorEncoder[leftDriveB]) + abs(nMotorEncoder[rightDriveB]))/2 < clicks) turn(speed);
	brake(-speed/2);
}

void straight(int speed){
	if(speed > 0){
		if(nMotorEncoder[leftDriveB] > nMotorEncoder[rightDriveB])
			setDrive((speed - 20), speed);
		if(nMotorEncoder[leftDriveB] < nMotorEncoder[rightDriveB])
			setDrive(speed, (speed - 20));
	}
	else{
		if(nMotorEncoder[leftDriveB] > nMotorEncoder[rightDriveB])
			setDrive(speed + 20, speed);
		if(nMotorEncoder[leftDriveB] < nMotorEncoder[rightDriveB])
			setDrive(speed, speed + 20);
	}
	if(nMotorEncoder[leftDriveB] == nMotorEncoder[rightDriveB])
		setDrive(speed, speed);
}

void straight_distance(int speed, long clicks){
	clearEncoder();
	while((nMotorEncoder[leftDriveB] + nMotorEncoder[rightDriveB])/2 < clicks)
		straight(speed);
	brake(-speed/2);
}


// ========================
// PRE-AUTONOMOUS FUNCTIONS
// ========================
void pre_auton()
{
	bStopTasksBetweenModes = true; // set to false if you want to preserve user-created tasks

	// temporary function call for testing
	//alignLine(1500, 70);
	//alignBack(40, 70);

	//diagonalSidle(30,90,RIGHT);
	//alignLine(1500, 90);

	// variables to be used in the while loop below
	autoSelector = 0;
	int autoIncrement = 0;
	sideSelector = 0;
	int sideIncrement = 0;
	string side = sides[sideSelector];
	string msg; // shows second row

	bLCDBacklight = true;
	ClearTimer(T3);
	while(time1[T3] < 2000){
		string temp1;
		string temp2;
		clearLCDLine(0);
		clearLCDLine(1);
		temp1 = sprintf(temp1, "Main: %1.2fv", nAvgBatteryLevel/1000);
		temp2 = sprintf(temp2, "Exp : %1.2fv", SensorValue(pwr_expander)/ (4* 45.6 ));
		displayLCDCenteredString(0, temp1);
		displayLCDCenteredString(1, temp2);
		wait1Msec(100);
	}
	ClearTimer(T1);
	while(time1[T1] < 2000) {
		// POLLING BUTTONS ==========
		if(nLCDButtons == 0) { // no buttons pressed
			// apply changes to autoSelector
			if(autoIncrement != 0) {
				autoSelector += autoIncrement;
				if(autoSelector < 0) {
					autoSelector = numAutos + autoSelector;
					} else {
					autoSelector %= numAutos; // loop around after highest auto number reached
				}
				autoIncrement = 0;
			}
			// apply changes to sideSelector
			if(sideIncrement != 0) {
				sideSelector += sideIncrement;
				sideSelector %= 2; // there are 2 possible sides, so only 0 and 1 possible
				sideIncrement = 0;
			}
			side = sides[sideSelector];
			// update bottom row message
			msg = sprintf(msg, " <   %s   > ", side);
			//" <   " + side + "   > ";
		}
		else if(nLCDButtons == 1) { // left button function: subtract from autoSelector
			autoIncrement = -1;
			msg = sprintf(msg, " <   %s   > ", side);
			//msg = "<    " + side + "   > ";
		}
		else if(nLCDButtons == 2) { // middle button function: toggle left right
			sideIncrement = 1;
		}
		else if(nLCDButtons == 4) { // right button function: add to autoSelector
			autoIncrement = 1;
			msg = sprintf(msg, " <   %s   > ", side);
			//msg = " <   " + side + "    >";
		}

		// UPDATE SCREEN ==========
		string buff;
		clearLCDLine(0);
		clearLCDLine(1);
		buff = sprintf(buff, "%i: %s", autoSelector, autoNames[autoSelector]);
		displayLCDCenteredString(0, buff);  //"" + autoSelector + ": " + autoNames[autoSelector]);
		displayLCDCenteredString(1, msg);
		wait1Msec(100);
	} // end of while loop

	/*
	while(true) {
	// UPDATE SCREEN ==========
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "" + SensorValue(lfdEncoder));
	wait1Msec(100);
	}
	*/
}

// ===============
// AUTONOMOUS TASK
// ===============
task autonomous()
{
	// TODO possibly move this to a autonomous
	runExpansion();

	switch(autoSelector) {
	case 0:
		expandSit(sideSelector);
		break;
	case 1:
		scoreTrough(sideSelector);
		break;
	case 2:
		block(sideSelector);
		break;
	case 3:
		moveForward(sideSelector);
		break;
	default:
		// do nothing
		break;
	}
}

// =================
// USER CONTROL TASK
// =================
task usercontrol()
{
	// User control code here, inside the loop
	//	turn_rotate(-80, RIGHT_TURN);
	//	alignBack(20, 40);
	/*
	StartTask(pneumatics);
	StartTask(arm_manager);
	runExpansion();

	alignBack(20, 60);

	strafe = true;
	SensorValue(basePneumatics) = 1;
	scoreTrough(RIGHT);
	*/
	scoreTrough(RIGHT);
	while(true){
		StartTask(drive);
		//	StartTask(arm);
		StartTask(arm_manager);
		StartTask(buttons);
		StartTask(pneumatics);

	}


}
