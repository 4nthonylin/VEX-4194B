#pragma config(UART_Usage, UART1, VEX_2x16_LCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl1,  basePneumatics, sensorDigitalOut)
#pragma config(Sensor, dgtl2,  clawPneumatics, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  leftUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  bLeftUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  topUltrasonic,  sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  bRightUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, dgtl11, rightUltrasonic, sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  lfdEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  lbdEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ll1Encoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ll2Encoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  rl2Encoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  rl1Encoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_7,  rbdEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_8,  rfdEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftRoll,      tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftDriveF,    tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           leftDriveB,    tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           leftLift1,     tmotorVex393, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port5,           leftLift2,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port6,           rightLift2,    tmotorVex393, openLoop, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port7,           rightLift1,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_6, 1000)
#pragma config(Motor,  port8,           rightDriveB,   tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_7, 1000)
#pragma config(Motor,  port9,           rightDriveF,   tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_8, 1000)
#pragma config(Motor,  port10,          rightRoll,     tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


int armState = 0; // 0 - 2, 0 = neutral, 1 = lift, 2 = down
int armSpeed[] = {10, 127, -60}; //0 = neutral, 1 = lift, 2 = down
int intakeSpeed = 127;
bool strafe = false;
bool driveEnable = true;


void setDrive(int left, int right);
void setDrive(int strafe);
void setDrive(int leftFront, int leftBack, int rightFront, int rightBack);
void runExpansion();
void setArm(int lift);
void setIntake(int speed);
void brake();


task drive();
task arm();
task buttons();
task pneumatics();


// AUTONOMOUS VARIABLES ==========
int sideSelector; // currently selected side
int LEFT = 0;
int RIGHT = 1;
int UP = 1;
int DOWN = 2;
string sides[] = {" LEFT ", " RIGHT"};
int autoSelector; // currently selected routine
int numAutos = 4; // number of autonomous routines
// autonomous routine tasks
string autoNames[] = {"Expand & Sit",
                      "Score Trough",
                      "Block",
                      "Move Forward"};

// autonomous routines
void auto0(int side);
void auto1(int side);
void auto2(int side);
void auto3(int side);
// named subroutines
void driveNE();
void driveNW();
void driveSW();
void driveSE();
void diagonalSidle();
void alignBack();
void alignLine();
void troughMacro();
// ===============================


task drive(){
	if(driveEnable){
		//setDrive(vexRT[Ch3], vexRT[Ch2]);
		motor[leftDriveF] = vexRT[Ch3] + vexRT[Ch4];
		motor[leftDriveB] = vexRT[Ch3] - vexRT[Ch4];
		motor[rightDriveF] = vexRT[Ch2] - vexRT[Ch1];
		motor[rightDriveB] = vexRT[Ch2] + vexRT[Ch1];
	}
}

task arm(){
	setArm(armSpeed[armState]);
}

task buttons(){
	if(strafe){
		if(vexRT[Btn8U] == 1){
			driveEnable = false;
			runExpansion();
		}
		else driveEnable = true;
	}
	if(vexRT[Btn7D] == 1) strafe = true;
	if(vexRT[Btn8D] == 1) strafe = false;

	if(vexRT[Btn5U] == 1) armState = UP;
	else if(vexRT[Btn5D] == 1) armState = DOWN;
	else armState = 0;

	if(vexRT[Btn8R] == 1) SensorValue(clawPneumatics) = 1;
	if(vexRT[Btn8L] == 1) SensorValue(clawPneumatics) = 0;

	if(vexRT[Btn6U] == 1) setIntake(intakeSpeed);
	else if(vexRT[Btn6D] == 1) setIntake(intakeSpeed*-1);
	else setIntake(0);
}

task pneumatics(){
	if(strafe){
		SensorValue(basePneumatics) = 1;
	}
	else{
		SensorValue(basePneumatics) = 0;
	}
}

void setDrive(int left, int right){
	motor[leftDriveF] = left;
	motor[leftDriveB] = left;
	motor[rightDriveF] = right;
	motor[rightDriveB] = right;
}

void setDrive(int strafe){
	motor[leftDriveF] = strafe * -1;
	motor[leftDriveB] = strafe;
	motor[rightDriveF] = strafe;
	motor[rightDriveB] = strafe * -1;
}

// NE - setDrive(1,0,0,1);
// NW - setDrive(0,1,1,0);
// SW - setDrive(-1,0,0,-1);
// SE - setDrive(0,-1,-1,0);
void setDrive(int leftFront, int leftBack, int rightFront, int rightBack) {
  motor[leftDriveF] = leftFront;
	motor[leftDriveB] = leftBack;
	motor[rightDriveF] = rightFront;
	motor[rightDriveB] = rightBack;
}

void runExpansion(){
	strafe = true;
	setDrive(127,127);
	wait1Msec(250);
	setDrive(-127,-127);
	wait1Msec(250);
	motor[leftDriveF] = 127;
	motor[leftDriveB] = -127;
	motor[rightDriveF] = 127;
	motor[rightDriveB] = -127;
	wait1Msec(250);
	brake();
}

void setArm(int lift){
	motor[leftLift1] = lift;
	motor[leftLift2] = lift;
	motor[rightLift1] = lift;
	motor[rightLift2] = lift;
}

void setIntake(int speed){
	motor[leftRoll] = speed;
	motor[rightRoll] = speed;
}

void brake(){
	setDrive(0, 0);
}

// ======================
// AUTONOMOUS SUBROUTINES
// ======================
void driveNE(int cw, int ccw) {
  setDrive(cw, 0, 0, ccw);
}
void driveNW(int cw, int ccw) {
  setDrive(0, cw, ccw, 0);
}
void driveSW(int cw, int ccw) {
  setDrive(-ccw, 0, 0, -cw);
}
void driveSE(int cw, int ccw) {
  setDrive(0, -ccw, -cw, 0);
}
void diagonalSidle(int dist, int speed, int side) {
  int rotateCW = speed; // clockwise rotation
  int rotateCCW = speed; // counterclockwise rotation

  if(side == LEFT) {
    /*
    while(SensorValue(leftUltrasonic) > dist) {
	    // drive NW
	    setDrive(0, rotateCW, rotateCCW, 0);
	  }
	  */
  } else if(side == RIGHT) {
	  while(SensorValue(rightUltrasonic) > dist) {
      // drive NE
	    if(SensorValue(bLeftUltrasonic) >= SensorValue(bRightUltrasonic)) { // too far clockwise
	      rotateCCW = speed++;
	      rotateCW = speed--;
	    } else { // too far counterclockwise
	      rotateCCW = speed--;
	      rotateCW = speed++;
	    }
	    driveNE(rotateCW, rotateCCW);

	  }
  }

	brake();
}

void alignLine(int value, int speed) {
  int leftMotor;
  int rightMotor;
  bool leftPassed = false;
  bool rightPassed = false;
  while(!rightPassed || !leftPassed) {
    if(SensorValue(leftLineFollower) < value) {
      leftPassed = true;
    }
    if(!leftPassed) {
      leftMotor = speed;
    } else {
      leftMotor = 10;
    }
    if(SensorValue(rightLineFollower) < value) {
      rightPassed = true;
    }
    if(!rightPassed) {
      rightMotor = speed;
    } else {
      rightMotor = 10;
    }
    setDrive(leftMotor,rightMotor);
  }
  brake();
}

void alignBack(int dist, int speed) {
  int leftMotor;
  int rightMotor;
  int threshold = 0;
  while(SensorValue(bLeftUltrasonic) > dist + threshold  || SensorValue(bLeftUltrasonic) < dist - threshold
     || SensorValue(bRightUltrasonic) > dist + threshold || SensorValue(bRightUltrasonic) < dist - threshold) {
    if(SensorValue(bLeftUltrasonic) > dist + threshold) {
      leftMotor = -speed;
    } else if(SensorValue(bLeftUltrasonic) < dist - threshold) {
      leftMotor = speed;
    } else {
      leftMotor = 0;
    }
    if(SensorValue(bRightUltrasonic) > dist + threshold) {
      rightMotor = -speed;
    } else if (SensorValue(bLeftUltrasonic) < dist - threshold) {
      rightMotor = speed;
    } else {
      rightMotor = 0;
    }
    setDrive(leftMotor, rightMotor);
  }
  brake();
}

void troughMacro(int speed) {
  // starts with back facing the trough
  // 1. move back and lift up


  setArm(armSpeed[UP]);
  // 2. move forward and drop lift
}

// ===================
// AUTONOMOUS ROUTINES
// ===================
void auto0(int side) {
  // 0: Expand & Sit

}
void auto1(int side) {
  // 1: Score Trough

}
void auto2(int side) {
  // 2: Block

}
void auto3(int side) {
  // 3: Move Forward

}

// ========================
// PRE-AUTONOMOUS FUNCTIONS
// ========================
void pre_auton()
{
	bStopTasksBetweenModes = true; // set to false if you want to preserve user-created tasks

	// temporary function call for testing
	//alignLine(1500, 70);
  //alignBack(40, 70);

  //diagonalSidle(30,90,RIGHT);
  //alignLine(1500, 90);

  // variables to be used in the while loop below
  autoSelector = 0;
  int autoIncrement = 0;
  sideSelector = 0;
  int sideIncrement = 0;
  string side = sides[sideSelector];
  string msg; // shows second row

  bLCDBacklight = true;

  while(true) {
    // POLLING BUTTONS ==========
    if(nLCDButtons == 0) { // no buttons pressed
      // apply changes to autoSelector
      if(autoIncrement != 0) {
        autoSelector += autoIncrement;
        if(autoSelector < 0) {
          autoSelector = numAutos + autoSelector;
        } else {
          autoSelector %= numAutos; // loop around after highest auto number reached
        }
        autoIncrement = 0;
      }
      // apply changes to sideSelector
      if(sideIncrement != 0) {
        sideSelector += sideIncrement;
        sideSelector %= 2; // there are 2 possible sides, so only 0 and 1 possible
        sideIncrement = 0;
      }
      side = sides[sideSelector];
      // update bottom row message
      msg = " <   " + side + "   > ";
    }
    else if(nLCDButtons == 1) { // left button function: subtract from autoSelector
      autoIncrement = -1;
      msg = "<    " + side + "   > ";
    }
    else if(nLCDButtons == 2) { // middle button function: toggle left right
      sideIncrement = 1;
    }
    else if(nLCDButtons == 4) { // right button function: add to autoSelector
      autoIncrement = 1;
      msg = " <   " + side + "    >";
    }

    // UPDATE SCREEN ==========
    clearLCDLine(0);
	  clearLCDLine(1);
	  displayLCDCenteredString(0, "" + autoSelector + ": " + autoNames[autoSelector]);
	  displayLCDCenteredString(1, msg);
	  wait1Msec(100);
  } // end of while loop

  /*
  while(true) {
  // UPDATE SCREEN ==========
    clearLCDLine(0);
	  clearLCDLine(1);
	  displayLCDCenteredString(0, "" + SensorValue(lfdEncoder));
	  wait1Msec(100);
	}
	*/
}

// ===============
// AUTONOMOUS TASK
// ===============
task autonomous()
{
	// TODO possibly move this to a autonomous
  runExpansion();

  switch(autoSelector) {
    case 0:
      auto0(sideSelector);
      break;
    case 1:
      auto1(sideSelector);
      break;
    case 2:
      auto2(sideSelector);
      break;
    case 3:
      auto3(sideSelector);
      break;
    default:
      // do nothing
      break;
  }
}

// =================
// USER CONTROL TASK
// =================
task usercontrol()
{
	// User control code here, inside the loop
	while(true){
		StartTask(drive);
		StartTask(arm);
		StartTask(buttons);
		StartTask(pneumatics);
	}

}
